--- old.genericCallInferenceUsingThisTypeNoInvalidCacheReuseAfterMappedTypeApplication1.types
+++ new.genericCallInferenceUsingThisTypeNoInvalidCacheReuseAfterMappedTypeApplication1.types
@@= skipped -31, +31 lines =@@
   extends Variance<A, E, R> {}

 declare const succeed: <A>(value: A) => Effect<A>;
->succeed : <A>(value: A) => Effect<A>
+>succeed : <A>(value: A) => Effect<A, never, never>
 >value : A

 type F<X, Y> = Y extends { _type: infer Z }
@@= skipped -21, +21 lines =@@
 };

 declare const implement: <T>() => <I extends ReadonlyArray<any>, X>(
->implement : <T>() => <I extends ReadonlyArray<any>, X>(x: (...i: I) => X) => (...i: I) => F<X, T>
+>implement : <T>() => <I extends readonly any[], X>(x: (...i: I) => X) => (...i: I) => F<X, T>

   x: (...i: I) => X,
 >x : (...i: I) => X
@@= skipped -15, +15 lines =@@
   log = implement<this>()(<N extends number>(n: N) => succeed(n));
 >log : <N extends number>(n: N) => F<Effect<N, never, never>, this>
 >implement<this>()(<N extends number>(n: N) => succeed(n)) : <N extends number>(n: N) => F<Effect<N, never, never>, this>
->implement<this>() : <I extends ReadonlyArray<any>, X>(x: (...i: I) => X) => (...i: I) => F<X, this>
->implement : <T>() => <I extends ReadonlyArray<any>, X>(x: (...i: I) => X) => (...i: I) => F<X, T>
+>implement<this>() : <I extends readonly any[], X>(x: (...i: I) => X) => (...i: I) => F<X, this>
+>implement : <T>() => <I extends readonly any[], X>(x: (...i: I) => X) => (...i: I) => F<X, T>
 ><N extends number>(n: N) => succeed(n) : <N extends number>(n: N) => Effect<N, never, never>
 >n : N
 >succeed(n) : Effect<N, never, never>
->succeed : <A>(value: A) => Effect<A>
+>succeed : <A>(value: A) => Effect<A, never, never>
 >n : N
 }

@@= skipped -16, +16 lines =@@
 >outer : ProxyMap<XXX>

 export const a = inner.log(100); // Effect<100, never, never>
->a : F<Effect<100, never, never>, this>
->inner.log(100) : F<Effect<100, never, never>, this>
->inner.log : <N extends number>(n: N) => F<Effect<N, never, never>, this>
+>a : Effect<100, never, never>
+>inner.log(100) : Effect<100, never, never>
+>inner.log : <N extends number>(n: N) => Effect<N, never, never>
 >inner : XXX
->log : <N extends number>(n: N) => F<Effect<N, never, never>, this>
+>log : <N extends number>(n: N) => Effect<N, never, never>
 >100 : 100

 export const b = outer.log(100); // Effect<100, never, XXX>
->b : F<Effect<100, never, never>, this>
->outer.log(100) : F<Effect<100, never, never>, this>
->outer.log : <N extends number>(n: N) => F<Effect<N, never, never>, this>
+>b : Effect<100, never, never>
+>outer.log(100) : Effect<100, never, never>
+>outer.log : <N extends number>(n: N) => Effect<N, never, never>
 >outer : ProxyMap<XXX>
->log : <N extends number>(n: N) => F<Effect<N, never, never>, this>
+>log : <N extends number>(n: N) => Effect<N, never, never>
 >100 : 100
