--- old.complexRecursiveCollections.types
+++ new.complexRecursiveCollections.types
@@= skipped -21, +21 lines =@@

     // these seem necessary to push it over the top for memory usage
     reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
->reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R_1>(reducer: (reduction: V | R_1, value: V, key: K, iter: this) => R_1): R_1; }
+>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R>(reducer: (reduction: R | V, value: V, key: K, iter: this) => R): R; }
 >reducer : (reduction: R, value: V, key: K, iter: this) => R
 >reduction : R
 >value : V
@@= skipped -10, +10 lines =@@
 >context : any

     reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
->reduce : { <R_1>(reducer: (reduction: R_1, value: V, key: K, iter: this) => R_1, initialReduction: R_1, context?: any): R_1; <R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R; }
->reducer : (reduction: V | R, value: V, key: K, iter: this) => R
+>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R>(reducer: (reduction: R | V, value: V, key: K, iter: this) => R): R; }
+>reducer : (reduction: R | V, value: V, key: K, iter: this) => R
 >reduction : R | V
 >value : V
 >key : K
@@= skipped -55, +55 lines =@@
 >Immutable : typeof Immutable

   export function fromJS(jsValue: any, reviver?: (key: string | number, sequence: Collection.Keyed<string, any> | Collection.Indexed<any>, path?: Array<string | number>) => any): any;
->fromJS : (jsValue: any, reviver?: (key: string | number, sequence: Collection.Keyed<string, any> | Collection.Indexed<any>, path?: Array<string | number>) => any) => any
+>fromJS : (jsValue: any, reviver?: (key: string | number, sequence: Collection.Indexed<any> | Collection.Keyed<string, any>, path?: (string | number)[]) => any) => any
 >jsValue : any
->reviver : (key: string | number, sequence: Collection.Keyed<string, any> | Collection.Indexed<any>, path?: Array<string | number>) => any
+>reviver : (key: string | number, sequence: Collection.Indexed<any> | Collection.Keyed<string, any>, path?: (string | number)[]) => any
 >key : string | number
 >sequence : Collection.Indexed<any> | Collection.Keyed<string, any>
 >Collection : any
@@= skipped -37, +37 lines =@@
 >Collection : any

   export function isAssociative(maybeAssociative: any): maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>;
->isAssociative : (maybeAssociative: any) => maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>
+>isAssociative : (maybeAssociative: any) => maybeAssociative is Collection.Indexed<any> | Collection.Keyed<any, any>
 >maybeAssociative : any
 >Collection : any
 >Collection : any
@@= skipped -29, +29 lines =@@
 >maybeList : any

     function of<T>(...values: Array<T>): List<T>;
->of : <T>(...values: Array<T>) => List<T>
+>of : <T>(...values: T[]) => List<T>
 >values : T[]
   }
   export function List(): List<any>;
@@= skipped -39, +39 lines =@@
 >clear : () => List<T>

     push(...values: Array<T>): List<T>;
->push : (...values: Array<T>) => List<T>
+>push : (...values: T[]) => List<T>
 >values : T[]

     pop(): List<T>;
 >pop : () => List<T>

     unshift(...values: Array<T>): List<T>;
->unshift : (...values: Array<T>) => List<T>
+>unshift : (...values: T[]) => List<T>
 >values : T[]

     shift(): List<T>;
@@= skipped -32, +32 lines =@@
 >value : this

     merge(...collections: Array<Collection.Indexed<T> | Array<T>>): this;
->merge : (...collections: Array<Collection.Indexed<T> | Array<T>>) => this
+>merge : (...collections: (T[] | Collection.Indexed<T>)[]) => this
 >collections : (T[] | Collection.Indexed<T>)[]
 >Collection : any

     mergeWith(merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>): this;
->mergeWith : (merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>) => this
+>mergeWith : (merger: (oldVal: T, newVal: T, key: number) => T, ...collections: (T[] | Collection.Indexed<T>)[]) => this
 >merger : (oldVal: T, newVal: T, key: number) => T
 >oldVal : T
 >newVal : T
@@= skipped -14, +14 lines =@@
 >Collection : any

     mergeDeep(...collections: Array<Collection.Indexed<T> | Array<T>>): this;
->mergeDeep : (...collections: Array<Collection.Indexed<T> | Array<T>>) => this
+>mergeDeep : (...collections: (T[] | Collection.Indexed<T>)[]) => this
 >collections : (T[] | Collection.Indexed<T>)[]
 >Collection : any

     mergeDeepWith(merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>): this;
->mergeDeepWith : (merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>) => this
+>mergeDeepWith : (merger: (oldVal: T, newVal: T, key: number) => T, ...collections: (T[] | Collection.Indexed<T>)[]) => this
 >merger : (oldVal: T, newVal: T, key: number) => T
 >oldVal : T
 >newVal : T
@@= skipped -45, +45 lines =@@
 >value : any

     mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
->mergeIn : (keyPath: Iterable<any>, ...collections: Array<any>) => this
+>mergeIn : (keyPath: Iterable<any>, ...collections: any[]) => this
 >keyPath : Iterable<any>
 >collections : any[]

     mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
->mergeDeepIn : (keyPath: Iterable<any>, ...collections: Array<any>) => this
+>mergeDeepIn : (keyPath: Iterable<any>, ...collections: any[]) => this
 >keyPath : Iterable<any>
 >collections : any[]

@@= skipped -23, +23 lines =@@

     // Sequence algorithms
     concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): List<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => List<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => List<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]

     map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): List<M>;
@@= skipped -43, +43 lines =@@
 >maybeMap : any

     function of(...keyValues: Array<any>): Map<any, any>;
->of : (...keyValues: Array<any>) => Map<any, any>
+>of : (...keyValues: any[]) => Map<any, any>
 >keyValues : any[]
   }
   export function Map<K, V>(collection: Iterable<[K, V]>): Map<K, V>;
@@= skipped -69, +69 lines =@@
 >value : this

     merge(...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
->merge : (...collections: Array<Collection<K, V> | { [key: string]: V; }>) => this
+>merge : (...collections: (Collection<K, V> | { [key: string]: V; })[]) => this
 >collections : (Collection<K, V> | { [key: string]: V; })[]
 >key : string

     mergeWith(merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
->mergeWith : (merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | { [key: string]: V; }>) => this
+>mergeWith : (merger: (oldVal: V, newVal: V, key: K) => V, ...collections: (Collection<K, V> | { [key: string]: V; })[]) => this
 >merger : (oldVal: V, newVal: V, key: K) => V
 >oldVal : V
 >newVal : V
@@= skipped -14, +14 lines =@@
 >key : string

     mergeDeep(...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
->mergeDeep : (...collections: Array<Collection<K, V> | { [key: string]: V; }>) => this
+>mergeDeep : (...collections: (Collection<K, V> | { [key: string]: V; })[]) => this
 >collections : (Collection<K, V> | { [key: string]: V; })[]
 >key : string

     mergeDeepWith(merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
->mergeDeepWith : (merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | { [key: string]: V; }>) => this
+>mergeDeepWith : (merger: (oldVal: V, newVal: V, key: K) => V, ...collections: (Collection<K, V> | { [key: string]: V; })[]) => this
 >merger : (oldVal: V, newVal: V, key: K) => V
 >oldVal : V
 >newVal : V
@@= skipped -41, +41 lines =@@
 >value : any

     mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
->mergeIn : (keyPath: Iterable<any>, ...collections: Array<any>) => this
+>mergeIn : (keyPath: Iterable<any>, ...collections: any[]) => this
 >keyPath : Iterable<any>
 >collections : any[]

     mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
->mergeDeepIn : (keyPath: Iterable<any>, ...collections: Array<any>) => this
+>mergeDeepIn : (keyPath: Iterable<any>, ...collections: any[]) => this
 >keyPath : Iterable<any>
 >collections : any[]

@@= skipped -23, +23 lines =@@

     // Sequence algorithms
     concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): Map<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Map<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): Map<string | K, C | V>; }
 >collections : Iterable<[KC, VC]>[]

     concat<C>(...collections: Array<{[key: string]: C}>): Map<K | string, V | C>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): Map<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Map<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): Map<string | K, C | V>; }
 >collections : { [key: string]: C; }[]
 >key : string

@@= skipped -85, +85 lines =@@
   export interface OrderedMap<K, V> extends Map<K, V> {
     // Sequence algorithms
     concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): OrderedMap<K | KC, V | VC>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): OrderedMap<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): OrderedMap<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): OrderedMap<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): OrderedMap<string | K, C | V>; }
 >collections : Iterable<[KC, VC]>[]

     concat<C>(...collections: Array<{[key: string]: C}>): OrderedMap<K | string, V | C>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): OrderedMap<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): OrderedMap<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): OrderedMap<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): OrderedMap<string | K, C | V>; }
 >collections : { [key: string]: C; }[]
 >key : string

@@= skipped -64, +64 lines =@@
 >maybeSet : any

     function of<T>(...values: Array<T>): Set<T>;
->of : <T>(...values: Array<T>) => Set<T>
+>of : <T>(...values: T[]) => Set<T>
 >values : T[]

     function fromKeys<T>(iter: Collection<T, any>): Set<T>;
@@= skipped -50, +50 lines =@@
 >clear : () => this

     union(...collections: Array<Collection<any, T> | Array<T>>): this;
->union : (...collections: Array<Collection<any, T> | Array<T>>) => this
+>union : (...collections: (T[] | Collection<any, T>)[]) => this
 >collections : (T[] | Collection<any, T>)[]

     merge(...collections: Array<Collection<any, T> | Array<T>>): this;
->merge : (...collections: Array<Collection<any, T> | Array<T>>) => this
+>merge : (...collections: (T[] | Collection<any, T>)[]) => this
 >collections : (T[] | Collection<any, T>)[]

     intersect(...collections: Array<Collection<any, T> | Array<T>>): this;
->intersect : (...collections: Array<Collection<any, T> | Array<T>>) => this
+>intersect : (...collections: (T[] | Collection<any, T>)[]) => this
 >collections : (T[] | Collection<any, T>)[]

     subtract(...collections: Array<Collection<any, T> | Array<T>>): this;
->subtract : (...collections: Array<Collection<any, T> | Array<T>>) => this
+>subtract : (...collections: (T[] | Collection<any, T>)[]) => this
 >collections : (T[] | Collection<any, T>)[]

     // Transient changes
@@= skipped -29, +29 lines =@@

     // Sequence algorithms
     concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Set<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => Set<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Set<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]

     map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Set<M>;
@@= skipped -43, +43 lines =@@
 >maybeOrderedSet : any

     function of<T>(...values: Array<T>): OrderedSet<T>;
->of : <T>(...values: Array<T>) => OrderedSet<T>
+>of : <T>(...values: T[]) => OrderedSet<T>
 >values : T[]

     function fromKeys<T>(iter: Collection<T, any>): OrderedSet<T>;
@@= skipped -25, +25 lines =@@
   export interface OrderedSet<T> extends Set<T> {
     // Sequence algorithms
     concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): OrderedSet<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => OrderedSet<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => OrderedSet<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]

     map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): OrderedSet<M>;
@@= skipped -36, +36 lines =@@
 >context : any

     zip(...collections: Array<Collection<any, any>>): OrderedSet<any>;
->zip : (...collections: Array<Collection<any, any>>) => OrderedSet<any>
+>zip : (...collections: Collection<any, any>[]) => OrderedSet<any>
 >collections : Collection<any, any>[]

     zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): OrderedSet<Z>;
->zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): OrderedSet<Z>; <U_1, V, Z_1>(zipper: (value: T, otherValue: U_1, thirdValue: V) => Z_1, otherCollection: Collection<any, U_1>, thirdCollection: Collection<any, V>): OrderedSet<Z_1>; <Z_1>(zipper: (...any: Array<any>) => Z_1, ...collections: Array<Collection<any, any>>): OrderedSet<Z_1>; }
+>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): OrderedSet<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z>; <Z>(zipper: (...any: any[]) => Z, ...collections: Collection<any, any>[]): OrderedSet<Z>; }
 >zipper : (value: T, otherValue: U) => Z
 >value : T
 >otherValue : U
 >otherCollection : Collection<any, U>

     zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z>;
->zipWith : { <U_1, Z_1>(zipper: (value: T, otherValue: U_1) => Z_1, otherCollection: Collection<any, U_1>): OrderedSet<Z_1>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z>; <Z_1>(zipper: (...any: Array<any>) => Z_1, ...collections: Array<Collection<any, any>>): OrderedSet<Z_1>; }
+>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): OrderedSet<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z>; <Z>(zipper: (...any: any[]) => Z, ...collections: Collection<any, any>[]): OrderedSet<Z>; }
 >zipper : (value: T, otherValue: U, thirdValue: V) => Z
 >value : T
 >otherValue : U
@@= skipped -20, +20 lines =@@
 >thirdCollection : Collection<any, V>

     zipWith<Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): OrderedSet<Z>;
->zipWith : { <U, Z_1>(zipper: (value: T, otherValue: U) => Z_1, otherCollection: Collection<any, U>): OrderedSet<Z_1>; <U, V, Z_1>(zipper: (value: T, otherValue: U, thirdValue: V) => Z_1, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z_1>; <Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): OrderedSet<Z>; }
->zipper : (...any: Array<any>) => Z
+>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): OrderedSet<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z>; <Z>(zipper: (...any: any[]) => Z, ...collections: Collection<any, any>[]): OrderedSet<Z>; }
+>zipper : (...any: any[]) => Z
 >any : any[]
 >collections : Collection<any, any>[]
   }
@@= skipped -13, +13 lines =@@
 >maybeStack : any

     function of<T>(...values: Array<T>): Stack<T>;
->of : <T>(...values: Array<T>) => Stack<T>
+>of : <T>(...values: T[]) => Stack<T>
 >values : T[]
   }
   export function Stack(): Stack<any>;
@@= skipped -18, +18 lines =@@

     // Reading values
     peek(): T | undefined;
->peek : () => T | undefined
+>peek : () => T

     // Persistent changes
     clear(): Stack<T>;
 >clear : () => Stack<T>

     unshift(...values: Array<T>): Stack<T>;
->unshift : (...values: Array<T>) => Stack<T>
+>unshift : (...values: T[]) => Stack<T>
 >values : T[]

     unshiftAll(iter: Iterable<T>): Stack<T>;
@@= skipped -18, +18 lines =@@
 >shift : () => Stack<T>

     push(...values: Array<T>): Stack<T>;
->push : (...values: Array<T>) => Stack<T>
+>push : (...values: T[]) => Stack<T>
 >values : T[]

     pushAll(iter: Iterable<T>): Stack<T>;
@@= skipped -24, +24 lines =@@

     // Sequence algorithms
     concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Stack<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => Stack<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Stack<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]

     map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Stack<M>;
@@= skipped -52, +52 lines =@@
 >Record : typeof Record

     export function isRecord(maybeRecord: any): maybeRecord is Record.Instance<any>;
->isRecord : (maybeRecord: any) => maybeRecord is Record.Instance<any>
+>isRecord : (maybeRecord: any) => maybeRecord is Instance<any>
 >maybeRecord : any
 >Record : any

@@= skipped -58, +58 lines =@@
 >value : T[K]

       merge(...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
->merge : (...collections: Array<Partial<T> | Iterable<[string, any]>>) => this
+>merge : (...collections: (Iterable<[string, any]> | Partial<T>)[]) => this
 >collections : (Iterable<[string, any]> | Partial<T>)[]

       mergeDeep(...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
->mergeDeep : (...collections: Array<Partial<T> | Iterable<[string, any]>>) => this
+>mergeDeep : (...collections: (Iterable<[string, any]> | Partial<T>)[]) => this
 >collections : (Iterable<[string, any]> | Partial<T>)[]

       mergeWith(merger: (oldVal: any, newVal: any, key: keyof T) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
->mergeWith : (merger: (oldVal: any, newVal: any, key: keyof T) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>) => this
+>mergeWith : (merger: (oldVal: any, newVal: any, key: keyof T) => any, ...collections: (Iterable<[string, any]> | Partial<T>)[]) => this
 >merger : (oldVal: any, newVal: any, key: keyof T) => any
 >oldVal : any
 >newVal : any
@@= skipped -16, +16 lines =@@
 >collections : (Iterable<[string, any]> | Partial<T>)[]

       mergeDeepWith(merger: (oldVal: any, newVal: any, key: any) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
->mergeDeepWith : (merger: (oldVal: any, newVal: any, key: any) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>) => this
+>mergeDeepWith : (merger: (oldVal: any, newVal: any, key: any) => any, ...collections: (Iterable<[string, any]> | Partial<T>)[]) => this
 >merger : (oldVal: any, newVal: any, key: any) => any
 >oldVal : any
 >newVal : any
@@= skipped -31, +31 lines =@@
 >value : any

       mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
->mergeIn : (keyPath: Iterable<any>, ...collections: Array<any>) => this
+>mergeIn : (keyPath: Iterable<any>, ...collections: any[]) => this
 >keyPath : Iterable<any>
 >collections : any[]

       mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
->mergeDeepIn : (keyPath: Iterable<any>, ...collections: Array<any>) => this
+>mergeDeepIn : (keyPath: Iterable<any>, ...collections: any[]) => this
 >keyPath : Iterable<any>
 >collections : any[]

@@= skipped -61, +61 lines =@@
 >Seq : typeof Seq

     function isSeq(maybeSeq: any): maybeSeq is Seq.Indexed<any> | Seq.Keyed<any, any>;
->isSeq : (maybeSeq: any) => maybeSeq is Seq.Indexed<any> | Seq.Keyed<any, any>
+>isSeq : (maybeSeq: any) => maybeSeq is Indexed<any> | Keyed<any, any>
 >maybeSeq : any
 >Seq : any
 >Seq : any

     function of<T>(...values: Array<T>): Seq.Indexed<T>;
->of : <T>(...values: Array<T>) => Seq.Indexed<T>
+>of : <T>(...values: T[]) => Indexed<T>
 >values : T[]
 >Seq : any

     export module Keyed {}
     export function Keyed<K, V>(collection: Iterable<[K, V]>): Seq.Keyed<K, V>;
->Keyed : { <K, V>(collection: Iterable<[K, V]>): Seq.Keyed<K, V>; <V_1>(obj: { [key: string]: V_1; }): Seq.Keyed<string, V_1>; <K_1, V_1>(): Seq.Keyed<K_1, V_1>; (): Seq.Keyed<any, any>; }
+>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: string]: V; }): Keyed<string, V>; <K_1, V_1>(): Keyed<K_1, V_1>; (): Keyed<any, any>; }
 >collection : Iterable<[K, V]>
 >Seq : any

     export function Keyed<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
->Keyed : { <K, V_1>(collection: Iterable<[K, V_1]>): Seq.Keyed<K, V_1>; <V>(obj: { [key: string]: V; }): Seq.Keyed<string, V>; <K, V_1>(): Seq.Keyed<K, V_1>; (): Seq.Keyed<any, any>; }
+>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: string]: V; }): Keyed<string, V>; <K, V_1>(): Keyed<K, V_1>; (): Keyed<any, any>; }
 >obj : { [key: string]: V; }
 >key : string
 >Seq : any

     export function Keyed<K, V>(): Seq.Keyed<K, V>;
->Keyed : { <K_1, V_1>(collection: Iterable<[K_1, V_1]>): Seq.Keyed<K_1, V_1>; <V_1>(obj: { [key: string]: V_1; }): Seq.Keyed<string, V_1>; <K, V>(): Seq.Keyed<K, V>; (): Seq.Keyed<any, any>; }
+>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: string]: V; }): Keyed<string, V>; <K, V>(): Keyed<K, V>; (): Keyed<any, any>; }
 >Seq : any

     export function Keyed(): Seq.Keyed<any, any>;
->Keyed : { <K, V>(collection: Iterable<[K, V]>): Seq.Keyed<K, V>; <V>(obj: { [key: string]: V; }): Seq.Keyed<string, V>; <K, V>(): Seq.Keyed<K, V>; (): Seq.Keyed<any, any>; }
+>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: string]: V; }): Keyed<string, V>; <K, V>(): Keyed<K, V>; (): Keyed<any, any>; }
 >Seq : any

     export interface Keyed<K, V> extends Seq<K, V>, Collection.Keyed<K, V> {
@@= skipped -44, +44 lines =@@
 >toSeq : () => this

       concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Seq.Keyed<K | KC, V | VC>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Seq.Keyed<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): Seq.Keyed<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): Keyed<string | K, C | V>; }
 >collections : Iterable<[KC, VC]>[]
 >Seq : any

       concat<C>(...collections: Array<{[key: string]: C}>): Seq.Keyed<K | string, V | C>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Seq.Keyed<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): Seq.Keyed<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): Keyed<string | K, C | V>; }
 >collections : { [key: string]: C; }[]
 >key : string
 >Seq : any

       map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Seq.Keyed<K, M>;
->map : <M>(mapper: (value: V, key: K, iter: this) => M, context?: any) => Seq.Keyed<K, M>
+>map : <M>(mapper: (value: V, key: K, iter: this) => M, context?: any) => Keyed<K, M>
 >mapper : (value: V, key: K, iter: this) => M
 >value : V
 >key : K
@@= skipped -20, +20 lines =@@
 >Seq : any

       mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Seq.Keyed<M, V>;
->mapKeys : <M>(mapper: (key: K, value: V, iter: this) => M, context?: any) => Seq.Keyed<M, V>
+>mapKeys : <M>(mapper: (key: K, value: V, iter: this) => M, context?: any) => Keyed<M, V>
 >mapper : (key: K, value: V, iter: this) => M
 >key : K
 >value : V
@@= skipped -9, +9 lines =@@
 >Seq : any

       mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Seq.Keyed<KM, VM>;
->mapEntries : <KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any) => Seq.Keyed<KM, VM>
+>mapEntries : <KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any) => Keyed<KM, VM>
 >mapper : (entry: [K, V], index: number, iter: this) => [KM, VM]
 >entry : [K, V]
 >index : number
@@= skipped -9, +9 lines =@@
 >Seq : any

       flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Seq.Keyed<any, any>;
->flatMap : <M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any) => Seq.Keyed<any, any>
+>flatMap : <M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any) => Keyed<any, any>
 >mapper : (value: V, key: K, iter: this) => Iterable<M>
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >Seq : any

       filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq.Keyed<K, F>;
->filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq.Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
+>filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
 >predicate : (value: V, key: K, iter: this) => value is F
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >Seq : any

       filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
->filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq.Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
+>filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
 >predicate : (value: V, key: K, iter: this) => any
 >value : V
 >key : K
@@= skipped -11, +11 lines =@@
 >Indexed : typeof Indexed

       function of<T>(...values: Array<T>): Seq.Indexed<T>;
->of : <T>(...values: Array<T>) => Seq.Indexed<T>
+>of : <T>(...values: T[]) => Indexed<T>
 >values : T[]
 >Seq : any
     }
@@= skipped -21, +21 lines =@@
 >Collection : typeof Collection

       toJS(): Array<any>;
->toJS : () => Array<any>
+>toJS : () => any[]

       toJSON(): Array<T>;
->toJSON : () => Array<T>
+>toJSON : () => T[]

       toSeq(): this;
 >toSeq : () => this

       concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Indexed<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => Seq.Indexed<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Indexed<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]
 >Seq : any

       map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Seq.Indexed<M>;
->map : <M>(mapper: (value: T, key: number, iter: this) => M, context?: any) => Seq.Indexed<M>
+>map : <M>(mapper: (value: T, key: number, iter: this) => M, context?: any) => Indexed<M>
 >mapper : (value: T, key: number, iter: this) => M
 >value : T
 >key : number
@@= skipped -23, +23 lines =@@
 >Seq : any

       flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Seq.Indexed<M>;
->flatMap : <M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any) => Seq.Indexed<M>
+>flatMap : <M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any) => Indexed<M>
 >mapper : (value: T, key: number, iter: this) => Iterable<M>
 >value : T
 >key : number
@@= skipped -9, +9 lines =@@
 >Seq : any

       filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Seq.Indexed<F>;
->filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Seq.Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
 >predicate : (value: T, index: number, iter: this) => value is F
 >value : T
 >index : number
@@= skipped -9, +9 lines =@@
 >Seq : any

       filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
->filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Seq.Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
 >predicate : (value: T, index: number, iter: this) => any
 >value : T
 >index : number
@@= skipped -11, +11 lines =@@
 >Set : typeof Set

       function of<T>(...values: Array<T>): Seq.Set<T>;
->of : <T>(...values: Array<T>) => Seq.Set<T>
+>of : <T>(...values: T[]) => Set<T>
 >values : T[]
 >Seq : any
     }
@@= skipped -21, +21 lines =@@
 >Collection : typeof Collection

       toJS(): Array<any>;
->toJS : () => Array<any>
+>toJS : () => any[]

       toJSON(): Array<T>;
->toJSON : () => Array<T>
+>toJSON : () => T[]

       toSeq(): this;
 >toSeq : () => this

       concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Set<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => Seq.Set<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Set<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]
 >Seq : any

       map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Seq.Set<M>;
->map : <M>(mapper: (value: T, key: never, iter: this) => M, context?: any) => Seq.Set<M>
+>map : <M>(mapper: (value: T, key: never, iter: this) => M, context?: any) => Set<M>
 >mapper : (value: T, key: never, iter: this) => M
 >value : T
 >key : never
@@= skipped -23, +23 lines =@@
 >Seq : any

       flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any): Seq.Set<M>;
->flatMap : <M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any) => Seq.Set<M>
+>flatMap : <M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any) => Set<M>
 >mapper : (value: T, key: never, iter: this) => Iterable<M>
 >value : T
 >key : never
@@= skipped -9, +9 lines =@@
 >Seq : any

       filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Seq.Set<F>;
->filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Seq.Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
 >predicate : (value: T, key: never, iter: this) => value is F
 >value : T
 >key : never
@@= skipped -9, +9 lines =@@
 >Seq : any

       filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
->filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Seq.Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
 >predicate : (value: T, key: never, iter: this) => any
 >value : T
 >key : never
@@= skipped -89, +89 lines =@@
 >Collection : typeof Collection

     function isKeyed(maybeKeyed: any): maybeKeyed is Collection.Keyed<any, any>;
->isKeyed : (maybeKeyed: any) => maybeKeyed is Collection.Keyed<any, any>
+>isKeyed : (maybeKeyed: any) => maybeKeyed is Keyed<any, any>
 >maybeKeyed : any
 >Collection : any

     function isIndexed(maybeIndexed: any): maybeIndexed is Collection.Indexed<any>;
->isIndexed : (maybeIndexed: any) => maybeIndexed is Collection.Indexed<any>
+>isIndexed : (maybeIndexed: any) => maybeIndexed is Indexed<any>
 >maybeIndexed : any
 >Collection : any

     function isAssociative(maybeAssociative: any): maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>;
->isAssociative : (maybeAssociative: any) => maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>
+>isAssociative : (maybeAssociative: any) => maybeAssociative is Indexed<any> | Keyed<any, any>
 >maybeAssociative : any
 >Collection : any
 >Collection : any
@@= skipped -21, +21 lines =@@

     export module Keyed {}
     export function Keyed<K, V>(collection: Iterable<[K, V]>): Collection.Keyed<K, V>;
->Keyed : { <K, V>(collection: Iterable<[K, V]>): Collection.Keyed<K, V>; <V_1>(obj: { [key: string]: V_1; }): Collection.Keyed<string, V_1>; }
+>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: string]: V; }): Keyed<string, V>; }
 >collection : Iterable<[K, V]>
 >Collection : any

     export function Keyed<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>;
->Keyed : { <K, V_1>(collection: Iterable<[K, V_1]>): Collection.Keyed<K, V_1>; <V>(obj: { [key: string]: V; }): Collection.Keyed<string, V>; }
+>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: string]: V; }): Keyed<string, V>; }
 >obj : { [key: string]: V; }
 >key : string
 >Collection : any
@@= skipped -27, +27 lines =@@
 >flip : () => this

       concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): Collection.Keyed<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): Keyed<string | K, C | V>; }
 >collections : Iterable<[KC, VC]>[]
 >Collection : any

       concat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>;
->concat : { <KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>; <C>(...collections: Array<{ [key: string]: C; }>): Collection.Keyed<K | string, V | C>; }
+>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: string]: C; }[]): Keyed<string | K, C | V>; }
 >collections : { [key: string]: C; }[]
 >key : string
 >Collection : any

       map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Collection.Keyed<K, M>;
->map : <M>(mapper: (value: V, key: K, iter: this) => M, context?: any) => Collection.Keyed<K, M>
+>map : <M>(mapper: (value: V, key: K, iter: this) => M, context?: any) => Keyed<K, M>
 >mapper : (value: V, key: K, iter: this) => M
 >value : V
 >key : K
@@= skipped -20, +20 lines =@@
 >Collection : any

       mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Collection.Keyed<M, V>;
->mapKeys : <M>(mapper: (key: K, value: V, iter: this) => M, context?: any) => Collection.Keyed<M, V>
+>mapKeys : <M>(mapper: (key: K, value: V, iter: this) => M, context?: any) => Keyed<M, V>
 >mapper : (key: K, value: V, iter: this) => M
 >key : K
 >value : V
@@= skipped -9, +9 lines =@@
 >Collection : any

       mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Collection.Keyed<KM, VM>;
->mapEntries : <KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any) => Collection.Keyed<KM, VM>
+>mapEntries : <KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any) => Keyed<KM, VM>
 >mapper : (entry: [K, V], index: number, iter: this) => [KM, VM]
 >entry : [K, V]
 >index : number
@@= skipped -9, +9 lines =@@
 >Collection : any

       flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Collection.Keyed<any, any>;
->flatMap : <M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any) => Collection.Keyed<any, any>
+>flatMap : <M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any) => Keyed<any, any>
 >mapper : (value: V, key: K, iter: this) => Iterable<M>
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >Collection : any

       filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Collection.Keyed<K, F>;
->filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Collection.Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
+>filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
 >predicate : (value: V, key: K, iter: this) => value is F
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >Collection : any

       filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
->filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Collection.Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
+>filter : { <F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Keyed<K, F>; (predicate: (value: V, key: K, iter: this) => any, context?: any): this; }
 >predicate : (value: V, key: K, iter: this) => any
 >value : V
 >key : K
@@= skipped -15, +15 lines =@@
     }
     export module Indexed {}
     export function Indexed<T>(collection: Iterable<T>): Collection.Indexed<T>;
->Indexed : <T>(collection: Iterable<T>) => Collection.Indexed<T>
+>Indexed : <T>(collection: Iterable<T>) => Indexed<T>
 >collection : Iterable<T>
 >Collection : any

     export interface Indexed<T> extends Collection<number, T> {
       toJS(): Array<any>;
->toJS : () => Array<any>
+>toJS : () => any[]

       toJSON(): Array<T>;
->toJSON : () => Array<T>
+>toJSON : () => T[]

       // Reading values
       get<NSV>(index: number, notSetValue: NSV): T | NSV;
->get : { <NSV>(index: number, notSetValue: NSV): T | NSV; (index: number): T | undefined; }
+>get : { <NSV>(index: number, notSetValue: NSV): NSV | T; (index: number): T; }
 >index : number
 >notSetValue : NSV

       get(index: number): T | undefined;
->get : { <NSV>(index: number, notSetValue: NSV): T | NSV; (index: number): T | undefined; }
+>get : { <NSV>(index: number, notSetValue: NSV): NSV | T; (index: number): T; }
 >index : number

       // Conversion to Seq
@@= skipped -36, +36 lines =@@
 >separator : T

       interleave(...collections: Array<Collection<any, T>>): this;
->interleave : (...collections: Array<Collection<any, T>>) => this
+>interleave : (...collections: Collection<any, T>[]) => this
 >collections : Collection<any, T>[]

       splice(index: number, removeNum: number, ...values: Array<T>): this;
->splice : (index: number, removeNum: number, ...values: Array<T>) => this
+>splice : (index: number, removeNum: number, ...values: T[]) => this
 >index : number
 >removeNum : number
 >values : T[]

       zip(...collections: Array<Collection<any, any>>): Collection.Indexed<any>;
->zip : (...collections: Array<Collection<any, any>>) => Collection.Indexed<any>
+>zip : (...collections: Collection<any, any>[]) => Indexed<any>
 >collections : Collection<any, any>[]
 >Collection : any

       zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): Collection.Indexed<Z>;
->zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): Collection.Indexed<Z>; <U_1, V, Z_1>(zipper: (value: T, otherValue: U_1, thirdValue: V) => Z_1, otherCollection: Collection<any, U_1>, thirdCollection: Collection<any, V>): Collection.Indexed<Z_1>; <Z_1>(zipper: (...any: Array<any>) => Z_1, ...collections: Array<Collection<any, any>>): Collection.Indexed<Z_1>; }
+>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): Indexed<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Indexed<Z>; <Z>(zipper: (...any: any[]) => Z, ...collections: Collection<any, any>[]): Indexed<Z>; }
 >zipper : (value: T, otherValue: U) => Z
 >value : T
 >otherValue : U
@@= skipped -23, +23 lines =@@
 >Collection : any

       zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Collection.Indexed<Z>;
->zipWith : { <U_1, Z_1>(zipper: (value: T, otherValue: U_1) => Z_1, otherCollection: Collection<any, U_1>): Collection.Indexed<Z_1>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Collection.Indexed<Z>; <Z_1>(zipper: (...any: Array<any>) => Z_1, ...collections: Array<Collection<any, any>>): Collection.Indexed<Z_1>; }
+>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): Indexed<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Indexed<Z>; <Z>(zipper: (...any: any[]) => Z, ...collections: Collection<any, any>[]): Indexed<Z>; }
 >zipper : (value: T, otherValue: U, thirdValue: V) => Z
 >value : T
 >otherValue : U
@@= skipped -10, +10 lines =@@
 >Collection : any

       zipWith<Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): Collection.Indexed<Z>;
->zipWith : { <U, Z_1>(zipper: (value: T, otherValue: U) => Z_1, otherCollection: Collection<any, U>): Collection.Indexed<Z_1>; <U, V, Z_1>(zipper: (value: T, otherValue: U, thirdValue: V) => Z_1, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Collection.Indexed<Z_1>; <Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): Collection.Indexed<Z>; }
->zipper : (...any: Array<any>) => Z
+>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): Indexed<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Indexed<Z>; <Z>(zipper: (...any: any[]) => Z, ...collections: Collection<any, any>[]): Indexed<Z>; }
+>zipper : (...any: any[]) => Z
 >any : any[]
 >collections : Collection<any, any>[]
 >Collection : any
@@= skipped -33, +33 lines =@@

       // Sequence algorithms
       concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Indexed<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => Collection.Indexed<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Indexed<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]
 >Collection : any

       map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Collection.Indexed<M>;
->map : <M>(mapper: (value: T, key: number, iter: this) => M, context?: any) => Collection.Indexed<M>
+>map : <M>(mapper: (value: T, key: number, iter: this) => M, context?: any) => Indexed<M>
 >mapper : (value: T, key: number, iter: this) => M
 >value : T
 >key : number
@@= skipped -14, +14 lines =@@
 >Collection : any

       flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Collection.Indexed<M>;
->flatMap : <M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any) => Collection.Indexed<M>
+>flatMap : <M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any) => Indexed<M>
 >mapper : (value: T, key: number, iter: this) => Iterable<M>
 >value : T
 >key : number
@@= skipped -9, +9 lines =@@
 >Collection : any

       filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Collection.Indexed<F>;
->filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Collection.Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
 >predicate : (value: T, index: number, iter: this) => value is F
 >value : T
 >index : number
@@= skipped -9, +9 lines =@@
 >Collection : any

       filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
->filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Collection.Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Indexed<F>; (predicate: (value: T, index: number, iter: this) => any, context?: any): this; }
 >predicate : (value: T, index: number, iter: this) => any
 >value : T
 >index : number
@@= skipped -15, +15 lines =@@
     }
     export module Set {}
     export function Set<T>(collection: Iterable<T>): Collection.Set<T>;
->Set : <T>(collection: Iterable<T>) => Collection.Set<T>
+>Set : <T>(collection: Iterable<T>) => Set<T>
 >collection : Iterable<T>
 >Collection : any

     export interface Set<T> extends Collection<never, T> {
       toJS(): Array<any>;
->toJS : () => Array<any>
+>toJS : () => any[]

       toJSON(): Array<T>;
->toJSON : () => Array<T>
+>toJSON : () => T[]

       toSeq(): Seq.Set<T>;
 >toSeq : () => Seq.Set<T>
@@= skipped -17, +17 lines =@@

       // Sequence algorithms
       concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Set<T | C>;
->concat : <C>(...valuesOrCollections: Array<Iterable<C> | C>) => Collection.Set<T | C>
+>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Set<C | T>
 >valuesOrCollections : (C | Iterable<C>)[]
 >Collection : any

       map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Collection.Set<M>;
->map : <M>(mapper: (value: T, key: never, iter: this) => M, context?: any) => Collection.Set<M>
+>map : <M>(mapper: (value: T, key: never, iter: this) => M, context?: any) => Set<M>
 >mapper : (value: T, key: never, iter: this) => M
 >value : T
 >key : never
@@= skipped -14, +14 lines =@@
 >Collection : any

       flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any):  Collection.Set<M>;
->flatMap : <M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any) => Collection.Set<M>
+>flatMap : <M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any) => Set<M>
 >mapper : (value: T, key: never, iter: this) => Iterable<M>
 >value : T
 >key : never
@@= skipped -9, +9 lines =@@
 >Collection : any

       filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Collection.Set<F>;
->filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Collection.Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
 >predicate : (value: T, key: never, iter: this) => value is F
 >value : T
 >key : never
@@= skipped -9, +9 lines =@@
 >Collection : any

       filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
->filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Collection.Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
+>filter : { <F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Set<F>; (predicate: (value: T, key: never, iter: this) => any, context?: any): this; }
 >predicate : (value: T, key: never, iter: this) => any
 >value : T
 >key : never
@@= skipped -40, +40 lines =@@

     // Reading values
     get<NSV>(key: K, notSetValue: NSV): V | NSV;
->get : { <NSV>(key: K, notSetValue: NSV): V | NSV; (key: K): V | undefined; }
+>get : { <NSV>(key: K, notSetValue: NSV): NSV | V; (key: K): V; }
 >key : K
 >notSetValue : NSV

     get(key: K): V | undefined;
->get : { <NSV>(key: K, notSetValue: NSV): V | NSV; (key: K): V | undefined; }
+>get : { <NSV>(key: K, notSetValue: NSV): NSV | V; (key: K): V; }
 >key : K

     has(key: K): boolean;
@@= skipped -21, +21 lines =@@
 >value : V

     first(): V | undefined;
->first : () => V | undefined
+>first : () => V

     last(): V | undefined;
->last : () => V | undefined
+>last : () => V

     // Reading deep values
     getIn(searchKeyPath: Iterable<any>, notSetValue?: any): any;
@@= skipped -23, +23 lines =@@

     // Conversion to JavaScript types
     toJS(): Array<any> | { [key: string]: any };
->toJS : () => Array<any> | { [key: string]: any; }
+>toJS : () => any[] | { [key: string]: any; }
 >key : string

     toJSON(): Array<V> | { [key: string]: V };
->toJSON : () => Array<V> | { [key: string]: V; }
+>toJSON : () => V[] | { [key: string]: V; }
 >key : string

     toArray(): Array<V>;
->toArray : () => Array<V>
+>toArray : () => V[]

     toObject(): { [key: string]: V };
 >toObject : () => { [key: string]: V; }
@@= skipped -204, +204 lines =@@

     // Combination
     concat(...valuesOrCollections: Array<any>): Collection<any, any>;
->concat : (...valuesOrCollections: Array<any>) => Collection<any, any>
+>concat : (...valuesOrCollections: any[]) => Collection<any, any>
 >valuesOrCollections : any[]

     flatten(depth?: number): Collection<any, any>;
@@= skipped -21, +21 lines =@@

     // Reducing a value
     reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
->reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R_1>(reducer: (reduction: V | R_1, value: V, key: K, iter: this) => R_1): R_1; }
+>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R>(reducer: (reduction: R | V, value: V, key: K, iter: this) => R): R; }
 >reducer : (reduction: R, value: V, key: K, iter: this) => R
 >reduction : R
 >value : V
@@= skipped -10, +10 lines =@@
 >context : any

     reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
->reduce : { <R_1>(reducer: (reduction: R_1, value: V, key: K, iter: this) => R_1, initialReduction: R_1, context?: any): R_1; <R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R; }
->reducer : (reduction: V | R, value: V, key: K, iter: this) => R
+>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R>(reducer: (reduction: R | V, value: V, key: K, iter: this) => R): R; }
+>reducer : (reduction: R | V, value: V, key: K, iter: this) => R
 >reduction : R | V
 >value : V
 >key : K
 >iter : this

     reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
->reduceRight : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R_1>(reducer: (reduction: V | R_1, value: V, key: K, iter: this) => R_1): R_1; }
+>reduceRight : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R>(reducer: (reduction: R | V, value: V, key: K, iter: this) => R): R; }
 >reducer : (reduction: R, value: V, key: K, iter: this) => R
 >reduction : R
 >value : V
@@= skipped -18, +18 lines =@@
 >context : any

     reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
->reduceRight : { <R_1>(reducer: (reduction: R_1, value: V, key: K, iter: this) => R_1, initialReduction: R_1, context?: any): R_1; <R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R; }
->reducer : (reduction: V | R, value: V, key: K, iter: this) => R
+>reduceRight : { <R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R; <R>(reducer: (reduction: R | V, value: V, key: K, iter: this) => R): R; }
+>reducer : (reduction: R | V, value: V, key: K, iter: this) => R
 >reduction : R | V
 >value : V
 >key : K
@@= skipped -51, +51 lines =@@

     // Search for value
     find(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): V | undefined;
->find : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => V | undefined
+>find : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => V
 >predicate : (value: V, key: K, iter: this) => boolean
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >notSetValue : V

     findLast(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): V | undefined;
->findLast : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => V | undefined
+>findLast : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => V
 >predicate : (value: V, key: K, iter: this) => boolean
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >notSetValue : V

     findEntry(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): [K, V] | undefined;
->findEntry : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => [K, V] | undefined
+>findEntry : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => [K, V]
 >predicate : (value: V, key: K, iter: this) => boolean
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >notSetValue : V

     findLastEntry(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): [K, V] | undefined;
->findLastEntry : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => [K, V] | undefined
+>findLastEntry : (predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V) => [K, V]
 >predicate : (value: V, key: K, iter: this) => boolean
 >value : V
 >key : K
@@= skipped -9, +9 lines =@@
 >notSetValue : V

     findKey(predicate: (value: V, key: K, iter: this) => boolean, context?: any): K | undefined;
->findKey : (predicate: (value: V, key: K, iter: this) => boolean, context?: any) => K | undefined
+>findKey : (predicate: (value: V, key: K, iter: this) => boolean, context?: any) => K
 >predicate : (value: V, key: K, iter: this) => boolean
 >value : V
 >key : K
@@= skipped -8, +8 lines =@@
 >context : any

     findLastKey(predicate: (value: V, key: K, iter: this) => boolean, context?: any): K | undefined;
->findLastKey : (predicate: (value: V, key: K, iter: this) => boolean, context?: any) => K | undefined
+>findLastKey : (predicate: (value: V, key: K, iter: this) => boolean, context?: any) => K
 >predicate : (value: V, key: K, iter: this) => boolean
 >value : V
 >key : K
@@= skipped -8, +8 lines =@@
 >context : any

     keyOf(searchValue: V): K | undefined;
->keyOf : (searchValue: V) => K | undefined
+>keyOf : (searchValue: V) => K
 >searchValue : V

     lastKeyOf(searchValue: V): K | undefined;
->lastKeyOf : (searchValue: V) => K | undefined
+>lastKeyOf : (searchValue: V) => K
 >searchValue : V

     max(comparator?: (valueA: V, valueB: V) => number): V | undefined;
->max : (comparator?: (valueA: V, valueB: V) => number) => V | undefined
+>max : (comparator?: (valueA: V, valueB: V) => number) => V
 >comparator : (valueA: V, valueB: V) => number
 >valueA : V
 >valueB : V

     maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): V | undefined;
->maxBy : <C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number) => V | undefined
+>maxBy : <C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number) => V
 >comparatorValueMapper : (value: V, key: K, iter: this) => C
 >value : V
 >key : K
@@= skipped -24, +24 lines =@@
 >valueB : C

     min(comparator?: (valueA: V, valueB: V) => number): V | undefined;
->min : (comparator?: (valueA: V, valueB: V) => number) => V | undefined
+>min : (comparator?: (valueA: V, valueB: V) => number) => V
 >comparator : (valueA: V, valueB: V) => number
 >valueA : V
 >valueB : V

     minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): V | undefined;
->minBy : <C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number) => V | undefined
+>minBy : <C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number) => V
 >comparatorValueMapper : (value: V, key: K, iter: this) => C
 >value : V
 >key : K