--- old.keyofAndIndexedAccess.js
+++ new.keyofAndIndexedAccess.js
@@= skipped -661, +661 lines =@@

 //// [keyofAndIndexedAccess.js]
 class Shape {
+    name;
+    width;
+    height;
+    visible;
 }
 class TaggedShape extends Shape {
+    tag;
 }
 class Item {
+    name;
+    price;
 }
 class Options {
+    visible;
 }
 function getProperty(obj, key) {
     return obj[key];
@@= skipped -36, +44 lines =@@
     let z = getProperty(foo, bar); // any
 }
 class Component {
+    props;
     getProperty(key) {
         return this.props[key];
     }
@@= skipped -41, +42 lines =@@
     let tag2 = getProperty(ts, "tag");
 }
 class C {
+    x;
+    y;
+    z;
 }
 // Indexed access expressions have always permitted access to private and protected members.
 // For consistency we also permit such access in indexed access types.
@@= skipped -89, +92 lines =@@
     let x2 = f83({ bar: { x: 42 } }, "bar"); // number
 }
 class C1 {
+    x;
     get(key) {
         return this[key];
     }
@@= skipped -50, +51 lines =@@
     }
 }
 class Person extends Base {
+    parts;
     constructor(parts) {
         super();
         this.set("parts", parts);
@@= skipped -9, +10 lines =@@
     }
 }
 class OtherPerson {
+    parts;
     constructor(parts) {
         setProperty(this, "parts", parts);
     }
@@= skipped -60, +61 lines =@@
 }
 // Repro from #13604
 class A {
+    props;
 }
 class B extends A {
     f(p) {
@@= skipped -8, +9 lines =@@
 }
 // Repro from #13749
 class Form {
+    childFormFactories;
     set(prop, value) {
         this.childFormFactories[prop](value);
     }
 }
 // Repro from #13787
 class SampleClass {
+    props;
     constructor(props) {
         this.props = Object.freeze(props);
     }
@@= skipped -400, +402 lines =@@
 declare const cf1: <T extends { [P in K]: string; } & {
     cool: string;
 }, K extends keyof T>(t: T, k: K) => void;
-declare const cf2: <T extends { [P in K | "cool"]: string; }, K extends keyof T>(t: T, k: K) => void;
+declare const cf2: <T extends { [P in "cool" | K]: string; }, K extends keyof T>(t: T, k: K) => void;